---
title: "Continuous Simulation"
author: "Tucker Morgan - tlm2152"
date: "2/16/2022"
output: pdf_document
---

```{r setup, echo = FALSE, message = FALSE, warning = FALSE, eval = FALSE, include = FALSE}
library(tidyverse)
library(simstudy)
library(MatchIt)
library(dplyr)
library(progress) 
library(ggpmisc)
library(cowplot)

# set knitr defaults
knitr::opts_chunk$set(
    echo      = TRUE
  , fig.align = "center"
  , fig.width = 6
  , fig.asp   = .6
  , out.width = "90%"
)

# set theme defaults
theme_set(
  theme_bw() +
  theme(
    legend.position = "bottom"
    , plot.title    = element_text(hjust = 0.5)
    , plot.subtitle = element_text(hjust = 0.5)
    , plot.caption  = element_text(hjust = 0.0)
  )
)

# set color scale defaults
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill   = "viridis"
)
scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete   = scale_fill_viridis_d
```
```{r covariate coef function, eval = FALSE, include = FALSE}
set.seed(100)
covariate_coef <- function(desired_prop, cov_df) {
   
     
   alpha_0 = log(desired_prop/(1 - desired_prop))
   
   coef_L1 <- sample(cov_df$L1, 10000, replace = TRUE)
   
   coef_L2 <- sample(cov_df$L2, 10000, replace = TRUE)
   
  # coef_L3 <- sample(cov_df$L3, 10000, replace = TRUE)
   
   A_logit <- vector(mode = "list",length = length(coef_L1))
   p_A <-  vector(mode = "numeric",length = length(coef_L1))
   
   u <- alpha_0 + coef_L1[1]*cov_df$L1 + coef_L2[1]*cov_df$L2 #- coef_L3[1]*cov_df$L3
   
   p_A[1] <-  mean(exp(u)/(1 + exp(u)))
   
   tol <- 0.001
   
   i = 1
   
   while (abs(p_A[i] - 0.14) > tol) {
     
     i = i + 1
     
     A_logit[[i]] <- 
       alpha_0 + coef_L1[i]*cov_df$L1 + coef_L2[i]*cov_df$L2 #- coef_L3[i]*cov_df$L3
     
     p_A[i] <- mean(exp(A_logit[[i]])/(1 + exp(A_logit[[i]])))
     
     if (abs(p_A[i] - 0.14) < tol) {
       mean_treated_proportion <- p_A[i]
       desired_coef_L1 <- coef_L1[i]
       desired_coef_L2 <- coef_L2[i]
      # desired_coef_L3 <- coef_L3[i]
     }
     
     if (i > length(coef_L1)) {
       stop("You need better coverage, mate.")
    }
     
   }
   
   return(tibble(alpha_0,  mean_treated_proportion, 
            desired_coef_L1, desired_coef_L2))#, desired_coef_L3))
}
```
```{r sub-pop generation, eval = FALSE, include = FALSE}
seed_vec <- rnorm(100000, mean = 0, sd = 100) %>% round(0) %>% unique()

generate_no_boot_data <- function(n, size = 5000, seeds = seed_vec) {
  
  df <- list()
  
  cov_df <- list()
  
  pb <- progress_bar$new(format = "generating data... [:bar]", total = n)
  
    for (i in 1:n) {
    pb$tick()
    set.seed(seeds[i])
    
    set.seed(seeds[i])
    pre_data <- defData(varname = "L1", formula = "0", variance = 1,
                dist = "normal")
    
    pre_data <- defData(pre_data, varname = "L2", formula = "0", variance = 10,
                dist = "normal")
    
    pre_data <- defData(pre_data, varname = "L3", formula = "0", variance = 10,
                dist = "normal")
    
    cov_df[[i]] <- genData(5000, pre_data)
    
    cov_coef_df <- covariate_coef(0.14, cov_df[[i]])
    
    L1_coef <- cov_coef_df$desired_coef_L1
    L2_coef <- cov_coef_df$desired_coef_L2
    #L3_coef <- cov_coef_df$desired_coef_L3

    pre_data <- defData(pre_data, varname = "L1_coef", formula = L1_coef)
    pre_data <- defData(pre_data, varname = "L2_coef", formula = L2_coef)
    #pre_data <- defData(pre_data, varname = "L3_coef", formula = L3_coef)
  
    pre_data <- defData(pre_data, varname = "A", 
                        formula = "-1.815 + L1_coef*L1 + L2_coef*L2",# + L3_coef*L3", 
                    dist = "binary", link = "logit")
    
    pre_data <- defData(pre_data, varname = "Y", 
                        formula = ".5 + 0.15*A + 2*L2 - 1*L3" , 
                    dist = "nonrandom")
    
    df[[i]] <- genData(size, pre_data)
    df[[i]] <- df[[i]] %>% select(-L1_coef, -L2_coef)#, -L3_coef)
    }
  return(df)
}

# ate_true = 0.15
no_boot_list <- generate_no_boot_data(100)
```

## Generating 100 Samples from Our Population
```{r calling data gen script}
source("./shared_code/data_gen_continuous.R")
```

Let's take a look at one of our "no-boot" aka sub-population data sets.

```{r distribution of treatment rate}
hist(map_dbl(1:length(no_boot_list), function(i) mean(no_boot_list[[i]]$A)), 
     main = "Hist of Treatment Dist",
     xlab = "Treat Rate",
     ylab = "Count")
```

```{r one sub-pop initial analysis}
no_boot_df1 <- no_boot_list[[1]]

sum(no_boot_df1$A) / nrow(no_boot_df1) # similar to desired_prop?
hist(no_boot_df1$Y, breaks = 100) # continuous distribution of outcome
```

## Implementing Nearest-Neighbor Matching

```{r implement NNM, warning=FALSE}
df <- no_boot_list

# could possible turn this into a function later.
matched_df <- list()

for (i in 1:length(df)) {
  
  matched <- matchit(A ~ L2 + L3, 
                     data = df[[i]], 
                     distance = "glm", 
                     link = "logit",
                     method = "nearest", 
                     ratio = 1) # perform NNM
  
  matched_df[[i]] <- match.data(matched, distance = "ps")
}
```

## The Simple Bootstrap

```{r calling in simple bootstrap}
source("./shared_code/boot_cont_simple.R")
```

## Summary of 1000 Simple Bootstraps in 100 Sub-Populations

```{r summary of results}
boot_result <-
  boot_estimates %>%
  group_by(seq) %>%
  summarize(ATE = mean(estimate), sd_ATE = sd(estimate))
 
fig1 <-
  boot_result %>%
  ggplot(aes(x = sd_ATE, color = sd_ATE)) +
  geom_histogram(fill = "light blue",  bins = 12,  color = "black") +
  geom_density(aes(y = ..density..*2), colour = "red", 
               fill = "black", alpha = 0.3) + 
  geom_vline(xintercept = mean(boot_result$sd_ATE), linetype = "dashed") + 
  labs(title = "SD of ATE from 1000 Bootstraps in 100 Sub-Populations",
       subtitle = "Distribution of bias",
  caption = "Ideal center: 0", x = "SD of ATE", y = "Frequency") + 
  theme(
  plot.title = element_text(color = "blue", size = 11, face = "bold"),
  plot.subtitle = element_text(color = "black"),
  plot.caption = element_text(color = "orange", face = "italic")
  )


fig2 <- 
  boot_result %>%
  ggplot(aes(x = ATE)) + 
  geom_histogram(fill = "light blue", bins = 12, color = "black") +
  geom_density(aes(y = ..density..*2), colour = "red", 
               fill = "black", alpha = 0.3) + 
  geom_vline(xintercept = mean(boot_result$ATE), linetype = "dashed") +
  labs(title = "Distribution of ATE in 1000 Bootstraps of 100 Sub-Populations", 
       caption = "Ideal center: 0.15", x = "Average Treatment Effect", y = "Frequency") + 
  theme(
  plot.title = element_text(color = "blue", size = 11, face = "bold"),
  plot.caption = element_text(color = "orange", face = "italic")
  )

plot_grid(fig1, fig2)
```

```{r cleaning up the environment}
rm(boot_estimates, boot_tib, df, matched, matched_df, matched_tib)
```

## Running Complex Bootstraps
```{r calling in complex boots}
source("./shared_code/boot_cont_complex.R")
```


## Confidence Intervals Coverage Rates

```{r coverage rate calculation, eval = FALSE, include = FALSE}
cvg_rate <- function(df){
  res = df %>% 
    mutate(ci_lower = ATE - 1.96*sd(ATE),
         ci_upper = ATE + 1.96*sd(ATE),
         covered = case_when(
           ci_lower <= beta1 & ci_upper >= beta1 ~ 1,
                                            TRUE ~ 0
         ))
  
  return(sum(res$covered) / nrow(res))
}

cvg_plot <- function(df){
  res = df %>% 
    mutate(ci_lower = ATE - 1.96*sd(ATE),
         ci_upper = ATE + 1.96*sd(ATE),
         covered = case_when(
           ci_lower <= beta1 & ci_upper >= beta1 ~ 1,
                                            TRUE ~ 0
         ))
  
  plot = res %>% 
    ggplot(aes(x = ATE, y = seq)) +
    geom_point() +
    geom_errorbar(aes(xmin = ci_lower, xmax = ci_upper)) +
    geom_vline(xintercept = beta1, linetype = "dashed")
  
  return(plot)
}

cvg_rate(boot_result)
cvg_plot(boot_result)
```

## Generating Output

```{r output}
cont_simple_df <- 
  boot_result %>% 
  mutate(ci_lower = ATE - 1.96*sd(ATE),
         ci_upper = ATE + 1.96*sd(ATE),
         covered = case_when(
           ci_lower <= beta1 & ci_upper >= beta1 ~ 1,
                                            TRUE ~ 0
         ),
         boot_type = c(0),
         scenario_id = c(0), # this needs to be updated each run
         empirical_mean = continuous_empirical_mean_se$empircal_mean,
         empirical_se = continuous_empirical_mean_se$empircal_se) %>% 
  tibble()

cont_complex_df <- 
  fin_estimate_df %>% 
  mutate(ci_lower = ATE - 1.96*sd(ATE),
         ci_upper = ATE + 1.96*sd(ATE),
         covered = case_when(
           ci_lower <= beta1 & ci_upper >= beta1 ~ 1,
                                            TRUE ~ 0
         ),
         boot_type = c(1),
         scenario_id = c(0), # this needs to be updated each run
         empirical_mean = continuous_empirical_mean_se$empircal_mean,
         empirical_se = continuous_empirical_mean_se$empircal_se) %>% 
  tibble() %>% 
  relocate(seq)

cont_df_scen_0 <- bind_rows(cont_simple_df, cont_complex_df)
  

save(cont_df_scen_0, file = "./output_data/continuous_test.RData")
```

